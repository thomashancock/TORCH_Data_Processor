\hypertarget{class_thread_safe_event_map}{}\section{Thread\+Safe\+Event\+Map Class Reference}
\label{class_thread_safe_event_map}\index{Thread\+Safe\+Event\+Map@{Thread\+Safe\+Event\+Map}}


Creates and stores events.  




{\ttfamily \#include $<$Thread\+Safe\+Event\+Map.\+hpp$>$}

\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{class_thread_safe_event_map_a766a347019971b1697e7e223290364b4}{Thread\+Safe\+Event\+Map} (const std\+::list$<$ \hyperlink{class_readout_identifier}{Readout\+Identifier} $>$ readout\+I\+Ds)
\begin{DoxyCompactList}\small\item\em Constructor. \end{DoxyCompactList}\item 
\hyperlink{class_thread_safe_event_map_a523d5bf6c632e3803e721ef3fd94e318}{Thread\+Safe\+Event\+Map} (const \hyperlink{class_thread_safe_event_map}{Thread\+Safe\+Event\+Map} \&other)=delete
\item 
\hyperlink{class_thread_safe_event_map}{Thread\+Safe\+Event\+Map} \& \hyperlink{class_thread_safe_event_map_a1d438208fcc3936dd4384a8a2b55bdf8}{operator=} (\hyperlink{class_thread_safe_event_map}{Thread\+Safe\+Event\+Map} other)=delete
\item 
\hyperlink{class_thread_safe_event_map_af28959f5fbd84f00d227d10e1b37e5e5}{Thread\+Safe\+Event\+Map} (const \hyperlink{class_thread_safe_event_map}{Thread\+Safe\+Event\+Map} \&\&other)=delete
\item 
\hyperlink{class_thread_safe_event_map}{Thread\+Safe\+Event\+Map} \& \hyperlink{class_thread_safe_event_map_a6bf7640fde19d7d6d4dedd5b06c09f84}{operator=} (\hyperlink{class_thread_safe_event_map}{Thread\+Safe\+Event\+Map} \&\&other)=delete
\item 
void \hyperlink{class_thread_safe_event_map_aafd485696f0a50da8afa864f04f0aa07}{add\+Packet} (std\+::unique\+\_\+ptr$<$ \hyperlink{class_packet}{Packet} $>$ packet)
\begin{DoxyCompactList}\small\item\em Add a packet to the events. \end{DoxyCompactList}\item 
bool \hyperlink{class_thread_safe_event_map_a9fb58083137d147811de5b93f991d044}{is\+Complete\+Stored} () const
\begin{DoxyCompactList}\small\item\em Is a complete event stored? \end{DoxyCompactList}\item 
bool \hyperlink{class_thread_safe_event_map_a203143086874b97171101871ba2c4f6f}{is\+Bloated} () const
\begin{DoxyCompactList}\small\item\em Returns whether the buffer is reaching capacity. \end{DoxyCompactList}\item 
std\+::vector$<$ std\+::unique\+\_\+ptr$<$ \hyperlink{class_event}{Event} $>$ $>$ \hyperlink{class_thread_safe_event_map_adc6c905693e3b9b54671299e7610d5b6}{pop\+To\+Complete} ()
\begin{DoxyCompactList}\small\item\em Returns events up to the next complete event. \end{DoxyCompactList}\item 
std\+::vector$<$ std\+::unique\+\_\+ptr$<$ \hyperlink{class_event}{Event} $>$ $>$ \hyperlink{class_thread_safe_event_map_a655bf86c67d1e8d0e8276b012f5fab8d}{dump\+Half} ()
\begin{DoxyCompactList}\small\item\em Returns first half of the events stored in the buffer. \end{DoxyCompactList}\item 
std\+::vector$<$ std\+::unique\+\_\+ptr$<$ \hyperlink{class_event}{Event} $>$ $>$ \hyperlink{class_thread_safe_event_map_af65f8dbd177f3db92d227b86839c275d}{dump\+All} ()
\begin{DoxyCompactList}\small\item\em Returns all events in the buffer. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Types}
\begin{DoxyCompactItemize}
\item 
using \hyperlink{class_thread_safe_event_map_a069c80cec7636a015d8a69574157d8d2}{event\+Map} = std\+::unordered\+\_\+map$<$ unsigned int, std\+::unique\+\_\+ptr$<$ \hyperlink{class_event}{Event} $>$ $>$
\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
const std\+::list$<$ \hyperlink{class_readout_identifier}{Readout\+Identifier} $>$ \hyperlink{class_thread_safe_event_map_a1b1ff8e56effaac464b1c9dbfb44320c}{m\+\_\+readout\+I\+Ds}
\begin{DoxyCompactList}\small\item\em List of Readout I\+Ds used to check when events are complete. \end{DoxyCompactList}\item 
std\+::mutex \hyperlink{class_thread_safe_event_map_ada4e8c2f2195df86503e73674ff30935}{m\+\_\+mut}
\begin{DoxyCompactList}\small\item\em Mutex used for thread safety. \end{DoxyCompactList}\item 
\hyperlink{class_thread_safe_event_map_a069c80cec7636a015d8a69574157d8d2}{event\+Map} \hyperlink{class_thread_safe_event_map_a15d9d8928ff7dc51fa48a1829575b47e}{m\+\_\+map}
\begin{DoxyCompactList}\small\item\em Map to store events. Key is event\+ID. \end{DoxyCompactList}\item 
std\+::list$<$ event\+Map\+::iterator $>$ \hyperlink{class_thread_safe_event_map_abfd8bf29e9ff254df217bd2b9e32f50c}{m\+\_\+event\+Tracker}
\begin{DoxyCompactList}\small\item\em List of entries in map used to store insertion order. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
Creates and stores events. 

Creates events based on added packets.

Events are stored in a map based on their event\+ID to facilitate quick adding of packets.

Insertion order is recorded so that incomplete events can be read out once a later complete event is found. 

\subsection{Member Typedef Documentation}
\mbox{\Hypertarget{class_thread_safe_event_map_a069c80cec7636a015d8a69574157d8d2}\label{class_thread_safe_event_map_a069c80cec7636a015d8a69574157d8d2}} 
\index{Thread\+Safe\+Event\+Map@{Thread\+Safe\+Event\+Map}!event\+Map@{event\+Map}}
\index{event\+Map@{event\+Map}!Thread\+Safe\+Event\+Map@{Thread\+Safe\+Event\+Map}}
\subsubsection{\texorpdfstring{event\+Map}{eventMap}}
{\footnotesize\ttfamily using \hyperlink{class_thread_safe_event_map_a069c80cec7636a015d8a69574157d8d2}{Thread\+Safe\+Event\+Map\+::event\+Map} =  std\+::unordered\+\_\+map$<$ unsigned int, std\+::unique\+\_\+ptr$<$\hyperlink{class_event}{Event}$>$ $>$\hspace{0.3cm}{\ttfamily [private]}}



\subsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{class_thread_safe_event_map_a766a347019971b1697e7e223290364b4}\label{class_thread_safe_event_map_a766a347019971b1697e7e223290364b4}} 
\index{Thread\+Safe\+Event\+Map@{Thread\+Safe\+Event\+Map}!Thread\+Safe\+Event\+Map@{Thread\+Safe\+Event\+Map}}
\index{Thread\+Safe\+Event\+Map@{Thread\+Safe\+Event\+Map}!Thread\+Safe\+Event\+Map@{Thread\+Safe\+Event\+Map}}
\subsubsection{\texorpdfstring{Thread\+Safe\+Event\+Map()}{ThreadSafeEventMap()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily Thread\+Safe\+Event\+Map\+::\+Thread\+Safe\+Event\+Map (\begin{DoxyParamCaption}\item[{const std\+::list$<$ \hyperlink{class_readout_identifier}{Readout\+Identifier} $>$}]{readout\+I\+Ds }\end{DoxyParamCaption})}



Constructor. 


\begin{DoxyParams}{Parameters}
{\em readout\+I\+Ds} & List of readout I\+Ds present in the config \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_thread_safe_event_map_a523d5bf6c632e3803e721ef3fd94e318}\label{class_thread_safe_event_map_a523d5bf6c632e3803e721ef3fd94e318}} 
\index{Thread\+Safe\+Event\+Map@{Thread\+Safe\+Event\+Map}!Thread\+Safe\+Event\+Map@{Thread\+Safe\+Event\+Map}}
\index{Thread\+Safe\+Event\+Map@{Thread\+Safe\+Event\+Map}!Thread\+Safe\+Event\+Map@{Thread\+Safe\+Event\+Map}}
\subsubsection{\texorpdfstring{Thread\+Safe\+Event\+Map()}{ThreadSafeEventMap()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily Thread\+Safe\+Event\+Map\+::\+Thread\+Safe\+Event\+Map (\begin{DoxyParamCaption}\item[{const \hyperlink{class_thread_safe_event_map}{Thread\+Safe\+Event\+Map} \&}]{other }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [delete]}}

\mbox{\Hypertarget{class_thread_safe_event_map_af28959f5fbd84f00d227d10e1b37e5e5}\label{class_thread_safe_event_map_af28959f5fbd84f00d227d10e1b37e5e5}} 
\index{Thread\+Safe\+Event\+Map@{Thread\+Safe\+Event\+Map}!Thread\+Safe\+Event\+Map@{Thread\+Safe\+Event\+Map}}
\index{Thread\+Safe\+Event\+Map@{Thread\+Safe\+Event\+Map}!Thread\+Safe\+Event\+Map@{Thread\+Safe\+Event\+Map}}
\subsubsection{\texorpdfstring{Thread\+Safe\+Event\+Map()}{ThreadSafeEventMap()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily Thread\+Safe\+Event\+Map\+::\+Thread\+Safe\+Event\+Map (\begin{DoxyParamCaption}\item[{const \hyperlink{class_thread_safe_event_map}{Thread\+Safe\+Event\+Map} \&\&}]{other }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [delete]}}



\subsection{Member Function Documentation}
\mbox{\Hypertarget{class_thread_safe_event_map_aafd485696f0a50da8afa864f04f0aa07}\label{class_thread_safe_event_map_aafd485696f0a50da8afa864f04f0aa07}} 
\index{Thread\+Safe\+Event\+Map@{Thread\+Safe\+Event\+Map}!add\+Packet@{add\+Packet}}
\index{add\+Packet@{add\+Packet}!Thread\+Safe\+Event\+Map@{Thread\+Safe\+Event\+Map}}
\subsubsection{\texorpdfstring{add\+Packet()}{addPacket()}}
{\footnotesize\ttfamily void Thread\+Safe\+Event\+Map\+::add\+Packet (\begin{DoxyParamCaption}\item[{std\+::unique\+\_\+ptr$<$ \hyperlink{class_packet}{Packet} $>$}]{packet }\end{DoxyParamCaption})}



Add a packet to the events. 


\begin{DoxyParams}{Parameters}
{\em packet} & \hyperlink{class_packet}{Packet} to be added \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_thread_safe_event_map_af65f8dbd177f3db92d227b86839c275d}\label{class_thread_safe_event_map_af65f8dbd177f3db92d227b86839c275d}} 
\index{Thread\+Safe\+Event\+Map@{Thread\+Safe\+Event\+Map}!dump\+All@{dump\+All}}
\index{dump\+All@{dump\+All}!Thread\+Safe\+Event\+Map@{Thread\+Safe\+Event\+Map}}
\subsubsection{\texorpdfstring{dump\+All()}{dumpAll()}}
{\footnotesize\ttfamily std\+::vector$<$ std\+::unique\+\_\+ptr$<$ \hyperlink{class_event}{Event} $>$ $>$ Thread\+Safe\+Event\+Map\+::dump\+All (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Returns all events in the buffer. 

\mbox{\Hypertarget{class_thread_safe_event_map_a655bf86c67d1e8d0e8276b012f5fab8d}\label{class_thread_safe_event_map_a655bf86c67d1e8d0e8276b012f5fab8d}} 
\index{Thread\+Safe\+Event\+Map@{Thread\+Safe\+Event\+Map}!dump\+Half@{dump\+Half}}
\index{dump\+Half@{dump\+Half}!Thread\+Safe\+Event\+Map@{Thread\+Safe\+Event\+Map}}
\subsubsection{\texorpdfstring{dump\+Half()}{dumpHalf()}}
{\footnotesize\ttfamily std\+::vector$<$ std\+::unique\+\_\+ptr$<$ \hyperlink{class_event}{Event} $>$ $>$ Thread\+Safe\+Event\+Map\+::dump\+Half (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Returns first half of the events stored in the buffer. 

\mbox{\Hypertarget{class_thread_safe_event_map_a203143086874b97171101871ba2c4f6f}\label{class_thread_safe_event_map_a203143086874b97171101871ba2c4f6f}} 
\index{Thread\+Safe\+Event\+Map@{Thread\+Safe\+Event\+Map}!is\+Bloated@{is\+Bloated}}
\index{is\+Bloated@{is\+Bloated}!Thread\+Safe\+Event\+Map@{Thread\+Safe\+Event\+Map}}
\subsubsection{\texorpdfstring{is\+Bloated()}{isBloated()}}
{\footnotesize\ttfamily bool Thread\+Safe\+Event\+Map\+::is\+Bloated (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Returns whether the buffer is reaching capacity. 

\mbox{\Hypertarget{class_thread_safe_event_map_a9fb58083137d147811de5b93f991d044}\label{class_thread_safe_event_map_a9fb58083137d147811de5b93f991d044}} 
\index{Thread\+Safe\+Event\+Map@{Thread\+Safe\+Event\+Map}!is\+Complete\+Stored@{is\+Complete\+Stored}}
\index{is\+Complete\+Stored@{is\+Complete\+Stored}!Thread\+Safe\+Event\+Map@{Thread\+Safe\+Event\+Map}}
\subsubsection{\texorpdfstring{is\+Complete\+Stored()}{isCompleteStored()}}
{\footnotesize\ttfamily bool Thread\+Safe\+Event\+Map\+::is\+Complete\+Stored (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Is a complete event stored? 

\mbox{\Hypertarget{class_thread_safe_event_map_a1d438208fcc3936dd4384a8a2b55bdf8}\label{class_thread_safe_event_map_a1d438208fcc3936dd4384a8a2b55bdf8}} 
\index{Thread\+Safe\+Event\+Map@{Thread\+Safe\+Event\+Map}!operator=@{operator=}}
\index{operator=@{operator=}!Thread\+Safe\+Event\+Map@{Thread\+Safe\+Event\+Map}}
\subsubsection{\texorpdfstring{operator=()}{operator=()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \hyperlink{class_thread_safe_event_map}{Thread\+Safe\+Event\+Map}\& Thread\+Safe\+Event\+Map\+::operator= (\begin{DoxyParamCaption}\item[{\hyperlink{class_thread_safe_event_map}{Thread\+Safe\+Event\+Map}}]{other }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [delete]}}

\mbox{\Hypertarget{class_thread_safe_event_map_a6bf7640fde19d7d6d4dedd5b06c09f84}\label{class_thread_safe_event_map_a6bf7640fde19d7d6d4dedd5b06c09f84}} 
\index{Thread\+Safe\+Event\+Map@{Thread\+Safe\+Event\+Map}!operator=@{operator=}}
\index{operator=@{operator=}!Thread\+Safe\+Event\+Map@{Thread\+Safe\+Event\+Map}}
\subsubsection{\texorpdfstring{operator=()}{operator=()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \hyperlink{class_thread_safe_event_map}{Thread\+Safe\+Event\+Map}\& Thread\+Safe\+Event\+Map\+::operator= (\begin{DoxyParamCaption}\item[{\hyperlink{class_thread_safe_event_map}{Thread\+Safe\+Event\+Map} \&\&}]{other }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [delete]}}

\mbox{\Hypertarget{class_thread_safe_event_map_adc6c905693e3b9b54671299e7610d5b6}\label{class_thread_safe_event_map_adc6c905693e3b9b54671299e7610d5b6}} 
\index{Thread\+Safe\+Event\+Map@{Thread\+Safe\+Event\+Map}!pop\+To\+Complete@{pop\+To\+Complete}}
\index{pop\+To\+Complete@{pop\+To\+Complete}!Thread\+Safe\+Event\+Map@{Thread\+Safe\+Event\+Map}}
\subsubsection{\texorpdfstring{pop\+To\+Complete()}{popToComplete()}}
{\footnotesize\ttfamily std\+::vector$<$ std\+::unique\+\_\+ptr$<$ \hyperlink{class_event}{Event} $>$ $>$ Thread\+Safe\+Event\+Map\+::pop\+To\+Complete (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Returns events up to the next complete event. 



\subsection{Member Data Documentation}
\mbox{\Hypertarget{class_thread_safe_event_map_abfd8bf29e9ff254df217bd2b9e32f50c}\label{class_thread_safe_event_map_abfd8bf29e9ff254df217bd2b9e32f50c}} 
\index{Thread\+Safe\+Event\+Map@{Thread\+Safe\+Event\+Map}!m\+\_\+event\+Tracker@{m\+\_\+event\+Tracker}}
\index{m\+\_\+event\+Tracker@{m\+\_\+event\+Tracker}!Thread\+Safe\+Event\+Map@{Thread\+Safe\+Event\+Map}}
\subsubsection{\texorpdfstring{m\+\_\+event\+Tracker}{m\_eventTracker}}
{\footnotesize\ttfamily std\+::list$<$event\+Map\+::iterator$>$ Thread\+Safe\+Event\+Map\+::m\+\_\+event\+Tracker\hspace{0.3cm}{\ttfamily [private]}}



List of entries in map used to store insertion order. 

\mbox{\Hypertarget{class_thread_safe_event_map_a15d9d8928ff7dc51fa48a1829575b47e}\label{class_thread_safe_event_map_a15d9d8928ff7dc51fa48a1829575b47e}} 
\index{Thread\+Safe\+Event\+Map@{Thread\+Safe\+Event\+Map}!m\+\_\+map@{m\+\_\+map}}
\index{m\+\_\+map@{m\+\_\+map}!Thread\+Safe\+Event\+Map@{Thread\+Safe\+Event\+Map}}
\subsubsection{\texorpdfstring{m\+\_\+map}{m\_map}}
{\footnotesize\ttfamily \hyperlink{class_thread_safe_event_map_a069c80cec7636a015d8a69574157d8d2}{event\+Map} Thread\+Safe\+Event\+Map\+::m\+\_\+map\hspace{0.3cm}{\ttfamily [private]}}



Map to store events. Key is event\+ID. 

\mbox{\Hypertarget{class_thread_safe_event_map_ada4e8c2f2195df86503e73674ff30935}\label{class_thread_safe_event_map_ada4e8c2f2195df86503e73674ff30935}} 
\index{Thread\+Safe\+Event\+Map@{Thread\+Safe\+Event\+Map}!m\+\_\+mut@{m\+\_\+mut}}
\index{m\+\_\+mut@{m\+\_\+mut}!Thread\+Safe\+Event\+Map@{Thread\+Safe\+Event\+Map}}
\subsubsection{\texorpdfstring{m\+\_\+mut}{m\_mut}}
{\footnotesize\ttfamily std\+::mutex Thread\+Safe\+Event\+Map\+::m\+\_\+mut\hspace{0.3cm}{\ttfamily [mutable]}, {\ttfamily [private]}}



Mutex used for thread safety. 

\mbox{\Hypertarget{class_thread_safe_event_map_a1b1ff8e56effaac464b1c9dbfb44320c}\label{class_thread_safe_event_map_a1b1ff8e56effaac464b1c9dbfb44320c}} 
\index{Thread\+Safe\+Event\+Map@{Thread\+Safe\+Event\+Map}!m\+\_\+readout\+I\+Ds@{m\+\_\+readout\+I\+Ds}}
\index{m\+\_\+readout\+I\+Ds@{m\+\_\+readout\+I\+Ds}!Thread\+Safe\+Event\+Map@{Thread\+Safe\+Event\+Map}}
\subsubsection{\texorpdfstring{m\+\_\+readout\+I\+Ds}{m\_readoutIDs}}
{\footnotesize\ttfamily const std\+::list$<$\hyperlink{class_readout_identifier}{Readout\+Identifier}$>$ Thread\+Safe\+Event\+Map\+::m\+\_\+readout\+I\+Ds\hspace{0.3cm}{\ttfamily [private]}}



List of Readout I\+Ds used to check when events are complete. 



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
Data\+Structures/inc/\hyperlink{_thread_safe_event_map_8hpp}{Thread\+Safe\+Event\+Map.\+hpp}\item 
Data\+Structures/src/\hyperlink{_thread_safe_event_map_8cpp}{Thread\+Safe\+Event\+Map.\+cpp}\end{DoxyCompactItemize}
